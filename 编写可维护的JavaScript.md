# 第7章 事件处理
所有的 javascript 均通过事件绑定到 UI 上

event 对象包含用户行为及浏览器行为相关的信息

应用逻辑和事件处理代码拆分吗，拆分出的应用逻辑与用户行为无关。
应用逻辑不应该依赖于 event 对象。

# 第8章 避免“空比较”
检测值的目的在于判断后续代码执行是否安全，因此比较条件应充分

## 8.1 检测原始值
* null 直接使用“===”
* string、number、boolean、undefined 使用 typeof

## 8.2 检测引用值
    //会检测原型链
    value instanceof constructor

## 8.2.1 检测函数
    typeof myFunc === "function"

## 8.2.2 检测数组
    Array.isArray(value)
    // 内部实现：
    Object.prototype.toString.call(value) === "[object Array]"

## 8.3 检测属性
    // 包括从对象的原型继承而来的属性
    prop in object

    // 不包括从对象的原型继承而来的属性
    object.hasOwnProperty("prop")

# 第9章 将配置数据从代码中分离出来
## 9.1 什么是配置数据
配置数据是可变更的。
* url
* 需要展现给用户的字符串
* 重复的值
* 设置（比如每页的配置项）
* 任何可能发生变更的值

## 9.2 抽离配置数据
将配置数据抽离保存为单独的对象

## 9.3 保存配置数据
最佳实践是保存在单独的文件中
* JSON
* JSONP
* 纯 JavaScript

# 第10章 抛出自定义的错误
抛出错误的目的不是避免错误，而是在错误发生时更容易定位调试
## 10.1 错误的本质
错误就是发生了意料之外的事情.
抛出错误使得错误可定位，可回溯
## 10.2 在 JavaScript 中抛出错误
throw 如果没有被 try-catch 语句捕获，就会引发一个错误
## 10.3 抛出错误的好处
为错误提供确切的文本，就想给自己留下告诉自己为什么失败的便签。
错误信息中始终包含函数的名称，函数失败的原因。
## 10.4 何时抛出错误
抛出错误的最佳的地方是工具函数中（比如各种类库）
* 修复很难调试的错误，尝试增加自定义错误
* 我希望不会发生的事如果发生了，抛出一个错误
* 如果不仅只有自己会使用，考虑别人可能会犯的错误，抛出一个错误。

## 10.5 try-catch 语句
底层的应用程序知道调用某个特定函数的原因，因此最适合处理错误，
在 catch 块中处理错误。

## 10.6 错误类型
* Error
* EvalError
* ReferenceError
* SyntaxError
* TypeError
* URIError

# 第11章 不是你的对象不要动

## 11.1 什么是你的
你的代码创建了这些对象
不是你的对象：
* 原生对象
* DOM对象
* BOM对象
* 类库的对象

## 11.2 原则
不覆盖、不新增、不删除
## 11.3 更好的途径
### 11.3.1 基于对象的继承
原型继承
Object.create()
### 11.3.2 基于类型的继承
与基于对象继承的区别是它通过构造函数实现