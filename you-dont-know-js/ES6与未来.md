# 第一章：ES？现在与未来
## 1.1 版本
注重支持的特性，而不是版本，介于 JS 在如此活跃积极的发展着。

## 1.2 转译
提前使用未被广泛支持的新特性，搭上新功能，新语法的早班车。

## 1.3 填补（Shims/Polyfills）
填补主要关注新的 API，一般情况下对新的语法无能为力。

# 第二章：语法
## 2.1 块儿作用域声明 
在 ES6 之前使用立即被调用的函数表达式（IIFE）

### 2.1.1 let声明
总是将let声明放在块儿的最顶端。如果你有多于一个的声明，我推荐只使用一个let。
let 在某种意义上劫持了它所处的{ .. }。
在let b语句运行之前你都不能访问b。
typeof 在let 创建的临时性死区中访问被声明但还没被赋值的变量时也会报错

#### let + for
在for头部中的let i不仅是为for循环本身声明了一个i，而且它为循环的每一次迭代都重新声明了一个新的i。
他可以代替原来需要用闭包才能完成的功能

let在for..in和for..of（参见“for..of循环”）循环中也以形同的方式工作。

### 2.1.2 const声明
一个const声明必须拥有一个明确的初始化。
#### const用还是不用
为了避免潜在的令人糊涂的代码，仅将const用于那些你有意地并且明显地标识为不会改变的变量。换言之，不要为了代码行为而 依靠 const，而是在为了意图可以被清楚地表明时，将它作为一个**表明意图**的工具。

### 2.1.3 块儿作用域的函数
依然存在函数生命提升，函数声明仅在块儿内有效

## 2.2 扩散/剩余
    // ... 用于收集参数，收入一个数组中
    function foo(...args) {
        // `args`已经是一个真正的数组了，

        // 丢弃`args`中的第一个元素
        args.shift();

        // 将`args`的所有内容作为参数值传给`console.log(..)`
        // ... 用于展开一个可迭代对象
        console.log( ...args );
    }

## 2.3 默认参数值
undefined意味着 缺失。
一个剩余/收集参数（参见“扩散/剩余”）不能拥有默认值。

### 2.3.1 默认值表达式
函数默认值可以是任何合法的表达式，甚至是函数调用：

在一个默认值表达式中的标识符引用会首先在正式参数的作用域中查找标识符，然后再查找一个外部作用域。

    // 因为 TDZ(暂时性死区) z = z + 1 会导致一个 ReferenceError
    function foo( x = w + 1, y = x + 1, z = z + 1 ) {
        console.log( x, y, z );
    }

虽然对于代码的清晰度来说不见得是一个好主意，一个默认值表达式甚至可以是一个内联的函数表达式调用 —— 通常被称为一个立即被调用的函数表达式（IIFE）：

## 2.4 解构
结构化赋值

### 2.4.1 对象属性赋值模式
对象字面量是target <-- source，而对象解构赋值是source --> target。
### 2.4.2 不仅是声明
你不应该将声明和赋值混在一起，除非你想要所有的赋值表达式 也 被视为声明。否则，你会得到一个语法错误。
可以为对象属性重命名，对象和属性互相简单的填充，只要指定一种对应的模式。

### 2.4.3 重复赋值
对象解构形式允许源属性（持有任意值的类型）被罗列多次。

解构的目的不仅是为了少打些字，更多是为了声明可读性

### 2.4.4 解构赋值表达式
带有对象或数组解构的赋值表达式的完成值是右手边完整的对象/数组值。
直接引用的最有，所以 = 连起来多个结构赋值都可以访问完整的最右表达式

### 2.4.5 太多，太少，正合适
... 操作符可以在数组的结构赋值中收集未对应的剩余成员

### 2.4.6 默认值赋值
使用和早先讨论过的默认函数参数值相似的=语法。

### 2.4.7 嵌套解构

### 2.4.8 参数解构
所有解构的种类对于参数解构来说都是可用的，包括嵌套解构，默认值，和其他。
解构也可以和其他ES6函数参数功能很好地混合在一起，比如默认参数值和剩余/收集参数。

#### 解构默认值 + 参数默认值
两者的差异是微妙的，一般情况下解构默认值可能会工作的更好

#### 嵌套默认值：解构与重构
你可以选择
1. 手动组合选项与选项默认值
2. Object.assign(..) 然而这是浅拷贝

如果我们将所有的属性完全解构为顶层变量，那么我们就可以立即重构来重组原本的嵌套对象解构。

其实是用结构赋值把 config 中的所有值平铺到一个块级作用域，并使用 default 设置中的默认值作为解构赋值的默认值。
然后再用这些经过解构赋值混入默认值的平铺开的值重构全新的config

## 2.5 对象字面量扩展
### 2.5.1 简约属性
	o = {
		x,
		y
	};

### 2.5.2 简约方法
    var o = {
        x() {
            // ..
        },
        *foo() { .. }
    }
#### 简约匿名
    runSomething( {
        something: function something(x,y) {
            // ..
        }
    } );
属性something让我们能够调用o.something(..)，有点儿像它的公有名称。
但是第二个something是一个词法名称，使这个函数可以为了递归而从内部引用它自己。

但是你应当仅在你永远不需要将它们用于递归或事件绑定/解除时使用简约方法。
否则，就坚持使用你的老式something: function something(..)方法定义。

#### ES5 Getter/Setter
    var o = {
        __id: 10,
        get id() { return this.__id++; },
        set id(v) { this.__id = v; }
    }
警告： 可能不太明显，但是setter字面量必须恰好有一个被声明的参数；省略它或罗列其他的参数都是不合法的语法。这个单独的必须参数 可以 使用解构和默认值（例如，set id({ id: v = 0 }) { .. }），但是收集/剩余...是不允许的（set id(...v) { .. }）。

### 2.5.3 计算型属性名
任何合法的表达式都可以出现在位于对象字面定义的属性名位置的[ .. ]内部。

计算型属性名还可以作为简约方法或简约generator的名称出现

### 2.5.4 设置[[Prototype]]
    var o2 = {
        __proto__: o1,
        // ..
    };
o2是用一个对象字面量声明的，但它也被[[Prototype]]链接到了o1。

### 2.5.5 对象super
super.XXX形式调用原型链上一层的方法。

## 2.6 模板字面量
插值型字符串字面量

`..`字符串字面量的结果只不过是一个简单的字符串。

除非在字面量值中作为明确的转义序列出现，回车字符\r（编码点U+000D）的值或者回车+换行序列\r\n（编码点U+000D和U+000A）的值都会被泛化为一个换行字符\n（编码点U+000A）。但不要担心；这种泛化很少见而且很可能仅会在你将文本拷贝粘贴到JS文件中时才会发生。

### 2.6.1 插值表达式
仅仅因为你 能 做某些事情，并不意味着你 应该 做这些事情。

#### 表达式作用域
一个插值型字符串字面量在它出现的地方是词法作用域的，而不是任何方式的动态作用域。

### 2.6.2 标签型模板字面量

### 2.6.3 原始字符串
原始版本的值保留了原始的转义序列\n

字符串字面量标签的其他用法包括国际化，本地化，和许多其他的特殊处理。

## 2.7 箭头函数
* 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且 没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。
* 如果你有一个内部函数表达式，它依赖于外围函数的var self = this黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。
* 如果你有一个内部函数表达式，它依赖于外围函数的类似于var args = Array.prototype.slice.call(arguments)这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。
* 对于其他的所有东西 —— 普通函数声明，较长的多语句函数表达式，需要词法名称标识符进行自引用（递归等）的函数，和任何其他不符合前述性质的函数 —— 你就可能应当避免=>函数语法。

## 2.8 for..of循环
不同于 for in，给出循环的值。

## 2.9 正则表达式扩展
### 2.9.1 Unicode标志
用于将 Unicode 字符识别为一个单独的字符

### 2.9.2 粘性标志
跳过正则

## 2.10 数字字面量扩展
    Number( "42" );			// 42
    Number( "0o52" );		// 42
    Number( "0x2a" );		// 42
    Number( "0b101010" );	// 42

## 2.11 Unicode

### 2.11.1 Unicode敏感的字符串操作

### 2.11.2 字符定位

## 2.12 Symbol
* 你不能也不应该将new与Symbol(..)一起使用。它不是一个构造器，你也不是在产生一个对象。
* 被传入Symbol(..)的参数是可选的。如果传入的话，它应当是一个字符串，为symbol的目的给出一个友好的描述。
* typeof的输出是一个新的值（"symbol"），这是识别一个symbol的主要方法。

### 2.12.1 Symbol注册表
Symbol.for(..)查询全局symbol注册表来查看一个symbol是否已经使用被提供的说明文本存储过了，如果有就返回它。如果没有，就创建一个并返回。

使用Symbol.keyFor(..)取得一个被注册的symbol描述文本（键）：

### 2.12.2 Symbols作为对象属性
要取得对象的symbol属性：

    Object.getOwnPropertySymbols( o );	// [ Symbol(bar) ]

# 第三章：组织
迭代器，generator，模块，和类。

## 3.1 迭代器
迭代器是一种消费数据的方法，它是组织有顺序的，相继的，基于抽取的。

### 3.1.1 接口
Iterator接口，它有如下的要求：

    Iterator [必须]
        next() {method}: 取得下一个IteratorResult
有两个可选成员，有些迭代器用它们进行了扩展：

    Iterator [可选]
        return() {method}: 停止迭代并返回IteratorResult
        throw() {method}: 通知错误并返回IteratorResult
接口IteratorResult被规定为：

    IteratorResult
        value {property}: 当前的迭代值或最终的返回值
            （如果它的值为`undefined`，是可选的）
        done {property}: 布尔值，指示完成的状态

还有一个Iterable接口，它描述了一定能够产生迭代器的对象：

    Iterable
        @@iterator() {method}: 产生一个迭代器

#### IteratorResult
IteratorResult接口规定从任何迭代器操作的返回值都是这样形式的对象：

    { value: .. , done: true / false }
如果有需要，也可以加入更多的返回值，但内建的 iterator 只返回上述的两个属性。

### 3.1.2 next()迭代

### 3.1.3 可选的return(..)和throw(..)
终止迭代器的迭代行为

### 3.1.4 迭代器循环
it.next()是在每次迭代之前被调用的，然后res.done才被查询。
所以一般情况下要先返回最后一个值，然后下一次才返回 done:true

### 3.1.5 自定义迭代器
some tricks TL:DR

### 3.1.6 消费迭代器
* 扩散操作符...将完全耗尽一个迭代器。
* 数组解构（参见第二章的“解构”）可以部分地或者完全地（如果与一个...剩余/收集操作符一起使用）消费一个迭代器：

## 3.2 Generator
### 3.2.1 语法
generator函数使用这种新语法声明：

    function *foo() {
        // ..
    }

### 3.2.2 执行一个Generator
像普通函数一样执行，然后生成一个用来控制它的迭代器

#### yield
一个yield..表达式可以出现在任意普通表达式可能出现的地方。

#### yield *
yield委托

### 3.2.2 迭代器控制
如果你仔细观察，这里有三个yield语句和四个next()调用。这可能看起来像是一个奇怪的不匹配。事实上，假定所有的东西都被求值并且generator完全运行至完成的话，next()调用将总是比yield表达式多一个。

### 3.2.3 提前完成

#### 提前中止

### 3.2.4 错误处理

### 3.2.5 转译一个Generator

### 3.2.6 Generator的使用

## 3.3 模块
### 3.3.1 过去的方式
主要利用闭包

### 3.3.2 向前迈进
#### CommonJS

### 3.3.3 新的方式


